#!/usr/bin/env ts-node

/**
 * QuickSites Coding Agent — Block Scaffolder
 * Self-contained: embeds Mustache templates + partials.
 *
 * Examples:
 *   # Dry run
 *   pnpm ts-node agents/coding/qs-block-agent.ts \
 *     --name image-carousel \
 *     --title "Image Carousel" \
 *     --group media \
 *     --fields 'images:array(url), autoplay:boolean, interval:number' \
 *     --dry-run
 *
 *   # Patch registries only (no files)
 *   pnpm ts-node agents/coding/qs-block-agent.ts \
 *     --name hours \
 *     --title "Hours of Operation" \
 *     --group business \
 *     --fields 'title:string, tz:string' \
 *     --no-files
 *
 *   # Alt outputs with PR title
 *   pnpm ts-node agents/coding/qs-block-agent.ts \
 *     --name hours \
 *     --title "Hours of Operation" \
 *     --group business \
 *     --fields 'title:string, tz:string' \
 *     --out-prefix autogen \
 *     --commit --open-pr --pr-title "feat(block): add hours (autogen) via agent"
 */

import { promises as fs } from 'fs';
import path from 'path';
import prompts from 'prompts';
import mustache from 'mustache';
import { execa } from 'execa';
// new
import { paramCase } from 'param-case';
import { camelCase } from 'camel-case';
import { pascalCase } from 'pascal-case';


// ------------------------------ Types ------------------------------

type Field = {
  name: string;
  type: string;          // string|text|number|boolean|url|color|enum|array(T)|object
  options?: string[];    // for enum
  default?: string;
  label?: string;
};

type Ctx = {
  name: string;          // kebab
  Name: string;          // Pascal
  camel: string;         // camel
  title: string;
  group: string;
  fields: Field[];
};

type FieldView = Field & {
  isString?: boolean;
  isText?: boolean;
  isNumber?: boolean;
  isBoolean?: boolean;
  isURL?: boolean;
  isColor?: boolean;
  isEnum?: boolean;
  isArray?: boolean;
  isObject?: boolean;
  arrayInnerZod?: string;
  labelOr?: string;
  ['-last']?: boolean;
};

// ------------------------------ Templates (embedded) ------------------------------

const TEMPLATES = {
  schema: `import * as z from 'zod';

// Auto-generated by qs-block-agent
export const {{camel}}ContentSchema = z.object({
  {{#fields}}
  {{name}}: {{> zodForField}}{{^-last}},{{/-last}}
  {{/fields}}
}).strict();

export type {{Name}}Content = z.infer<typeof {{camel}}ContentSchema>;
`,

  renderer: `'use client';
import type { JSX } from 'react';
import type { Block } from '@/types/blocks';
import SectionShell from '@/components/ui/section-shell';

// Auto-generated by qs-block-agent
export default function {{Name}}Render({ block }: { block: Block }): JSX.Element {
  const c = (block?.content as any) || {};
  return (
    <SectionShell id={block?.id} className="py-10">
      <div className="prose dark:prose-invert max-w-4xl">
        <h2>{{title}}</h2>
        <pre className="text-xs bg-neutral-900/50 p-3 rounded-xl overflow-auto">
{JSON.stringify(c, null, 2)}
        </pre>
      </div>
    </SectionShell>
  );
}
`,

  editor: `'use client';
import * as React from 'react';
import { Label } from '@/components/ui/label';
import { Input, Textarea, Switch } from '@/components/ui';
import Collapsible from '@/components/ui/collapsible-panel';
import type { Block } from '@/types/blocks';

// Auto-generated by qs-block-agent
export default function {{Name}}Editor({ block, onPatch }: { block: Block, onPatch: (p: any) => void }) {
  const c = (block?.content as any) || {};
  const set = (k: string, v: any) => onPatch({ path: ['content', k], value: v });

  return (
    <Collapsible title="{{title}}" defaultOpen>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {{#fields}}
        <div className="space-y-2">
          <Label>{{labelOr}}</Label>
{{> editorForField}}
        </div>
        {{/fields}}
      </div>
    </Collapsible>
  );
}
`,

  partials: {
    zodForField: `
{{#isString}}z.string(){{/isString}}
{{#isText}}z.string().min(0){{/isText}}
{{#isNumber}}z.number(){{/isNumber}}
{{#isBoolean}}z.boolean(){{/isBoolean}}
{{#isURL}}z.string().url(){{/isURL}}
{{#isColor}}z.string().regex(/^#([0-9a-fA-F]{3}){1,2}$/){{/isColor}}
{{#isEnum}}z.enum([{{#options}}'{{.}}'{{^-last}}, {{/-last}}{{/options}}]){{/isEnum}}
{{#isArray}}z.array({{arrayInnerZod}}){{/isArray}}
{{#isObject}}z.record(z.any()){{/isObject}}
`.trim(),

    editorForField: `
{{#isString}}
  <Input value={c['{{name}}'] ?? ''} onChange={e => set('{{name}}', e.target.value)} />
{{/isString}}
{{#isText}}
  <Textarea value={c['{{name}}'] ?? ''} onChange={e => set('{{name}}', e.target.value)} />
{{/isText}}
{{#isNumber}}
  <Input type="number" value={c['{{name}}'] ?? ''} onChange={e => set('{{name}}', Number(e.target.value))} />
{{/isNumber}}
{{#isBoolean}}
  <div className="flex items-center gap-3">
    <Switch checked={!!c['{{name}}']} onCheckedChange={(v) => set('{{name}}', v)} />
  </div>
{{/isBoolean}}
{{#isURL}}
  <Input type="url" value={c['{{name}}'] ?? ''} onChange={e => set('{{name}}', e.target.value)} />
{{/isURL}}
{{#isColor}}
  <Input type="color" value={c['{{name}}'] ?? '#6366F1'} onChange={e => set('{{name}}', e.target.value)} />
{{/isColor}}
{{#isEnum}}
  <select className="qs-select" value={c['{{name}}'] ?? ''} onChange={e => set('{{name}}', e.target.value)}>
    <option value="">— Select —</option>
    {{#options}}<option value="{{.}}">{{.}}</option>{{/options}}
  </select>
{{/isEnum}}
{{#isArray}}
  {/* Simple CSV editor for arrays */}
  <Input placeholder="Comma-separated"
    value={(c['{{name}}'] || []).join(', ')}
    onChange={e => set('{{name}}', e.target.value.split(/\\s*,\\s*/).filter(Boolean))} />
{{/isArray}}
{{#isObject}}
  <Textarea placeholder="JSON" value={JSON.stringify(c['{{name}}'] ?? {}, null, 2)}
    onChange={e => { try { set('{{name}}', JSON.parse(e.target.value)); } catch {} }} />
{{/isObject}}
`.trim(),
  },
};

// ------------------------------ Helpers ------------------------------

function parseFields(spec?: string): Field[] {
  if (!spec) return [];
  return spec.split(',').map((raw) => {
    const s = raw.trim();
    const [lhs, rhsFull] = splitOnce(s, ':');
    if (!lhs || !rhsFull) throw new Error(`Bad field token: "${s}"`);
    const name = lhs.trim();
    const typeWithInner = rhsFull.trim();

    const typeMatch = typeWithInner.match(/^([a-zA-Z]+)(\(([^)]+)\))?/);
    if (!typeMatch) throw new Error(`Bad type for token: "${s}"`);
    const baseType = typeMatch[1];
    const inner = typeMatch[3];

    const remaining = typeWithInner.slice(typeMatch[0].length).trim();
    let qualifiers: Record<string, string> = {};
    const qMatch = remaining.match(/^\(([^)]+)\)$/);
    if (qMatch) qualifiers = parseQualifiers(qMatch[1]);

    const f: Field = { name, type: baseType };
    if (baseType === 'array' && inner) f.type = `array(${inner.trim()})`;
    if (baseType === 'enum') {
      const optionsStr = qualifiers.options || (inner?.startsWith('options=') ? inner.slice('options='.length) : '');
      if (!optionsStr) throw new Error(`enum requires options (token: "${s}")`);
      f.options = optionsStr.split('|').map((x) => x.trim()).filter(Boolean);
    }
    if (qualifiers.label) f.label = stripQuotes(qualifiers.label);
    if (qualifiers.default) f.default = stripQuotes(qualifiers.default);
    return f;
  });
}

function enrichFieldsForView(fields: Field[]): FieldView[] {
  return fields.map((f, i) => {
    const v: FieldView = {
      ...f,
      labelOr: f.label || f.name,
      isString: f.type === 'string',
      isText: f.type === 'text',
      isNumber: f.type === 'number',
      isBoolean: f.type === 'boolean',
      isURL: f.type === 'url',
      isColor: f.type === 'color',
      isEnum: f.type === 'enum',
      isArray: f.type.startsWith('array('),
      isObject: f.type === 'object',
      arrayInnerZod: undefined,
      ['-last']: i === fields.length - 1,
    };
    if (v.isArray) {
      const inner = f.type.slice(6, -1);
      v.arrayInnerZod = fieldToZod(inner);
    }
    return v;
  });
}

function fieldToZod(t: string): string {
  switch (t) {
    case 'string':
    case 'text': return 'z.string()';
    case 'number': return 'z.number()';
    case 'boolean': return 'z.boolean()';
    case 'url': return 'z.string().url()';
    case 'color': return 'z.string()';
    default: return 'z.any()';
  }
}

function splitOnce(s: string, delim: string): [string, string] {
  const idx = s.indexOf(delim);
  if (idx === -1) return [s, ''];
  return [s.slice(0, idx), s.slice(idx + delim.length)];
}

function parseQualifiers(s: string): Record<string, string> {
  const out: Record<string, string> = {};
  s.split(',').forEach((piece) => {
    const [k, v] = splitOnce(piece.trim(), '=');
    if (!k || !v) return;
    out[k.trim()] = v.trim();
  });
  return out;
}

function stripQuotes(s: string): string {
  return s.replace(/^"(.*)"$/, '$1').replace(/^'(.*)'$/, '$1');
}

async function writeFileSafely(p: string, content: string, dry: boolean) {
  if (dry) { console.log(`── would write: ${p}`); return; }
  await fs.mkdir(path.dirname(p), { recursive: true });
  await fs.writeFile(p, content, 'utf8');
  console.log(`✅ wrote: ${p}`);
}

async function applyPatch(file: string, mut: (src: string) => string, dry: boolean) {
  const abs = path.join(process.cwd(), file);
  let src: string;
  try {
    src = await fs.readFile(abs, 'utf8');
  } catch {
    throw new Error(`Cannot read ${file}. Adjust --registry/--schemaMap to your repo paths.`);
  }
  const out = mut(src);
  if (dry) console.log(`── would patch: ${file}`);
  else { await fs.writeFile(abs, out, 'utf8'); console.log(`🔧 patched: ${file}`); }
}

async function run(cmd: string, args: string[], opts: any = {}) {
  await execa(cmd, args, { stdio: 'inherit', ...opts });
}

function prev(v: any) { return typeof v === 'string' && v.length > 0; }
async function maybe<T>(fn: () => Promise<T>) { try { return await fn(); } catch { /* noop */ } }

// ------------------------------ Wiring ------------------------------

function wireRenderer(src: string, ctx: Ctx, fileBaseName: string) {
  // import
  if (!src.includes(`render-blocks/${fileBaseName}`)) {
    const reactAnchor = src.match(/import\s+.+from\s+'react';?\s*\n/);
    const importLine = `import ${ctx.Name}Render from '@/components/admin/templates/render-blocks/${fileBaseName}';\n`;
    if (reactAnchor) src = src.replace(reactAnchor[0], reactAnchor[0] + importLine);
    else src = importLine + src;
  }
  // registry add
  if (!src.includes(`'${ctx.name}': ${ctx.Name}Render`)) {
    const re = /(export\s+const\s+BLOCK_REGISTRY\s*=\s*\{)([\s\S]*?)(\}\s*;)/m;
    if (!re.test(src)) throw new Error(`Could not locate BLOCK_REGISTRY in renderBlockRegistry.ts`);
    src = src.replace(re, (_m, a, mid, b) => `${a}${mid}\n  '${ctx.name}': ${ctx.Name}Render,\n${b}`);
  }
  return src;
}

function wireSchema(src: string, ctx: Ctx, schemaBaseName: string) {
  // import
  if (!src.includes(`./blocks/${schemaBaseName}`)) {
    const zAnchor = src.match(/import\s+\*\s+as\s+z\s+from\s+'zod';?\s*\n/);
    const importLine = `import { ${ctx.camel}ContentSchema } from './blocks/${schemaBaseName}';\n`;
    if (zAnchor) src = src.replace(zAnchor[0], zAnchor[0] + importLine);
    else src = importLine + src;
  }
  // map add
  if (!src.includes(`'${ctx.name}': ${ctx.camel}ContentSchema`)) {
    const re = /(export\s+const\s+blockContentSchemaMap\s*=\s*\{)([\s\S]*?)(\}\s*;)/m;
    if (!re.test(src)) throw new Error(`Could not locate blockContentSchemaMap in blockSchema.ts`);
    src = src.replace(re, (_m, a, mid, b) => `${a}${mid}\n  '${ctx.name}': ${ctx.camel}ContentSchema,\n${b}`);
  }
  return src;
}

// ------------------------------ Main ------------------------------

(async () => {
  const argv = Object.fromEntries(
    process.argv.slice(2).map((a) => {
      const [k, v] = a.startsWith('--') ? a.slice(2).split('=') : [a, 'true'];
      return [k, v === undefined ? 'true' : v];
    })
  );

  const initial = {
    name: argv.name,
    title: argv.title,
    group: argv.group || 'general',
    fields: argv.fields,
  };

  const answers = await prompts(
    [
      { type: prev(initial.name) ? null : 'text', name: 'name', message: 'Block name (kebab-case):' },
      { type: prev(initial.title) ? null : 'text', name: 'title', message: 'Block title (label):' },
      { type: prev(initial.group) ? null : 'text', name: 'group', message: 'Block group:' },
      { type: prev(initial.fields) ? null : 'text', name: 'fields', message: 'Fields spec:' },
    ],
    { onCancel: () => process.exit(1) }
  );

  const name = paramCase(answers.name || initial.name);
  const ctx: Ctx = {
    name,
    Name: pascalCase(name),
    camel: camelCase(name),
    title: answers.title || initial.title,
    group: answers.group || initial.group,
    fields: parseFields(answers.fields || initial.fields),
  };

  const dry = argv['dry-run'] === 'true' || argv['dry-run'] === '';
  const commit = argv.commit === 'true' || argv.commit === '';
  const openPr = argv['open-pr'] === 'true' || argv['open-pr'] === '';
  const prTitle = typeof argv['pr-title'] === 'string' ? argv['pr-title'] : '';
  const noFiles = argv['no-files'] === 'true' || argv['no-files'] === '';
  const outPrefix = typeof argv['out-prefix'] === 'string' ? argv['out-prefix'] : '';
  const registryPath = (argv['registry'] as string) || path.join('lib', 'renderBlockRegistry.ts');
  const schemaMapPath = (argv['schemaMap'] as string) || path.join('admin/lib/zod', 'blockSchema.ts');

  // Compute output basenames respecting --out-prefix
  const fileBase = outPrefix ? `${ctx.name}-${outPrefix}` : ctx.name;                 // for renderer/editor
  const schemaBase = outPrefix ? `${ctx.name}-${outPrefix}-schema` : `${ctx.name}-schema`;

  // Output targets
  const OUTS = {
    schema: path.join('admin/lib/zod/blocks', `${schemaBase}.ts`),
    renderer: path.join('components/admin/templates/render-blocks', `${fileBase}.tsx`),
    editor: path.join('components/admin/templates/block-editors', `${fileBase}-editor.tsx`),
    registry: registryPath,
    schemaMap: schemaMapPath,
    rendererImportBase: fileBase,   // import path base (no extension)
    schemaImportBase: schemaBase,   // import path base (no extension)
  };

  console.log('🔧 Generating block with context:\n', { ...ctx, outPrefix, noFiles, registryPath, schemaMapPath });

  // 1) Render files (unless --no-files)
  const fieldViews = enrichFieldsForView(ctx.fields);
  const commonView = { ...ctx, fields: fieldViews };

  if (!noFiles) {
    const schemaOut = mustache.render(TEMPLATES.schema, commonView, {
      zodForField: TEMPLATES.partials.zodForField,
    });
    await writeFileSafely(OUTS.schema, schemaOut, dry);

    const rendererOut = mustache.render(TEMPLATES.renderer, commonView);
    await writeFileSafely(OUTS.renderer, rendererOut, dry);

    const editorOut = mustache.render(TEMPLATES.editor, commonView, {
      editorForField: TEMPLATES.partials.editorForField,
    });
    await writeFileSafely(OUTS.editor, editorOut, dry);
  } else {
    console.log('⚠️  --no-files set: skipping schema/renderer/editor generation.');
  }

  // 2) Wire registries
  await applyPatch(OUTS.registry, (s) => wireRenderer(s, ctx, OUTS.rendererImportBase), dry);
  await applyPatch(OUTS.schemaMap, (s) => wireSchema(s, ctx, OUTS.schemaImportBase), dry);

  // 3) Optional: run typecheck & lint (best-effort)
  await maybe(() => run('pnpm', ['-s', 'typecheck']));
  await maybe(() => run('pnpm', ['-s', 'lint', '--fix']));

  // 4) Commit & PR
  if (commit) {
    await maybe(() => run('git', ['checkout', '-b', `agent/block/${ctx.name}`]));
    await maybe(() => run('git', ['add', '.']));
    await maybe(() => run('git', ['commit', '-m', `feat(block): add ${ctx.name}${outPrefix ? ` (${outPrefix})` : ''} via agent`]));
  }
  if (openPr) {
    if (prTitle) {
      await maybe(() => run('gh', ['pr', 'create', '--title', prTitle]));
    } else {
      await maybe(() => run('gh', ['pr', 'create', '--fill']));
    }
  }

  console.log('✅ Done.');
})();
