# Overview

This patch adds a **first‑class AI cost layer** you can: (1) seed into Supabase; (2) call from your merchant/product/template seeders; (3) surface in Profile & Template UIs; and (4) meter real usage post‑call.

It’s split into:
- **SQL**: pricing + estimates + usage tables
- **TS libs**: pricing fetchers, assumptions, estimators
- **Seeder helper**: drop‑in for your existing seed flow
- **UI**: Profile card + Template panel
- **Metering wrapper**: log actuals per API call

All numbers come from **`ai_model_pricing`** records. If a required price is missing, the estimator **throws** (your preferred no‑silent‑fallback behavior).

---

## 1) Supabase migration
**`supabase/migrations/20250829_ai_cost.sql`**
```sql
-- Pricing catalog per model/modality. Keep amounts nullable for modalities you don't use.
create table if not exists public.ai_model_pricing (
  id uuid primary key default gen_random_uuid(),
  provider text not null,                 -- e.g., 'openai', 'anthropic', 'google'
  model_code text not null,               -- e.g., 'gpt-4o-mini', 'claude-3-haiku'
  modality text not null check (modality in ('chat','embeddings','image','audio_stt','audio_tts')),

  -- unit prices in USD; nullable when not applicable to modality
  input_per_1k_usd numeric(12,6),        -- chat/embeddings: prompt tokens per 1k
  output_per_1k_usd numeric(12,6),       -- chat: completion tokens per 1k
  image_base_usd numeric(12,6),          -- image: flat per image
  image_per_mp_usd numeric(12,6),        -- image: per megapixel add‑on (optional)
  stt_per_min_usd numeric(12,6),         -- audio STT: per minute
  tts_per_1k_chars_usd numeric(12,6),    -- audio TTS: per 1k characters

  currency text not null default 'USD',
  is_active boolean not null default true,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique(provider, model_code, modality)
);

create or replace function public.ai_model_pricing_touch_updated()
returns trigger language plpgsql as $$
begin new.updated_at = now(); return new; end;
$$;

create trigger ai_model_pricing_touch_updated_trg
before update on public.ai_model_pricing
for each row execute function public.ai_model_pricing_touch_updated();

-- Point‑in‑time **estimates** attached to a specific entity.
create table if not exists public.ai_estimates (
  id uuid primary key default gen_random_uuid(),
  entity_type text not null check (entity_type in ('merchant','product','template','site')),
  entity_id uuid not null,
  provider text not null,
  model_code text not null,
  assumptions jsonb not null,
  input_tokens int not null default 0,
  output_tokens int not null default 0,
  images int not null default 0,
  minutes_audio numeric(12,3) not null default 0,
  estimated_cost_usd numeric(14,6) not null,
  breakdown jsonb not null,             -- per block/page/action subtotals
  created_by uuid,                      -- user id (nullable when batch seeding)
  created_at timestamptz not null default now()
);

create index if not exists ai_estimates_entity_idx
  on public.ai_estimates (entity_type, entity_id, created_at desc);

-- **Actuals**: log each real call's usage for reconciliation.
create table if not exists public.ai_usage_events (
  id uuid primary key default gen_random_uuid(),
  user_id uuid,
  site_id uuid,
  template_id uuid,
  provider text not null,
  model_code text not null,
  modality text not null,
  input_tokens int default 0,
  output_tokens int default 0,
  images int default 0,
  minutes_audio numeric(12,3) default 0,
  cost_usd numeric(14,6) not null,
  metadata jsonb,
  occurred_at timestamptz not null default now()
);

create index if not exists ai_usage_events_template_idx
  on public.ai_usage_events (template_id, occurred_at desc);
```

---

## 2) Pricing fetcher + types
**`lib/ai/cost/pricing.ts`**
```ts
import { createClient } from '@supabase/supabase-js';

// Use your existing admin client if you have one; this is self-contained.
const supabaseAdmin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  { auth: { persistSession: false } }
);

export type Modality = 'chat'|'embeddings'|'image'|'audio_stt'|'audio_tts';

export type ModelPricing = {
  provider: string;
  model_code: string;
  modality: Modality;
  input_per_1k_usd?: number | null;
  output_per_1k_usd?: number | null;
  image_base_usd?: number | null;
  image_per_mp_usd?: number | null;
  stt_per_min_usd?: number | null;
  tts_per_1k_chars_usd?: number | null;
};

export async function getPricing(provider: string, model_code: string, modality: Modality): Promise<ModelPricing> {
  const { data, error } = await supabaseAdmin
    .from('ai_model_pricing')
    .select('*')
    .eq('provider', provider)
    .eq('model_code', model_code)
    .eq('modality', modality)
    .eq('is_active', true)
    .maybeSingle();
  if (error || !data) {
    throw new Error(`Pricing missing for ${provider}:${model_code} (${modality})`);
  }
  return data as unknown as ModelPricing;
}
```

---

## 3) Assumptions per action/block (editable in one place)
**`lib/ai/cost/assumptions.ts`**
```ts
/**
 * Token assumptions are conservative estimates per action. 
 * Tune these over time; UI exposes them for what‑if scenarios.
 */
export type BlockAssumption = {
  prompt_in: number;   // expected input tokens (prompt + system + context)
  gen_out: number;     // expected output tokens
};

export type AssumptionProfile = {
  code: 'BASIC'|'RICH'|'MAX';
  label: string;
  // per block type; unknown types default to 0/0
  blocks: Record<string, BlockAssumption>;
  // page‑level extras (e.g., SEO/meta, schema, etc.)
  perPage?: BlockAssumption;
  // template‑level extras (site‑wide synopsis, brand voice crafting, etc.)
  perTemplate?: BlockAssumption;
  // global multipliers
  regenerationFactor?: number; // e.g., 1.0 = single pass, 1.5 = some retries
};

const ZERO: BlockAssumption = { prompt_in: 0, gen_out: 0 };

export const ASSUMPTIONS: Record<AssumptionProfile['code'], AssumptionProfile> = {
  BASIC: {
    code: 'BASIC',
    label: 'Lean (single‑pass, short copy)',
    blocks: {
      hero: { prompt_in: 300, gen_out: 180 },
      services: { prompt_in: 250, gen_out: 220 },   // per service item handled in estimator
      testimonials: { prompt_in: 180, gen_out: 140 },
      page_header: { prompt_in: 120, gen_out: 90 },
      contact_form: ZERO,
      service_areas: { prompt_in: 200, gen_out: 160 },
      faq: { prompt_in: 220, gen_out: 240 },
      about: { prompt_in: 260, gen_out: 240 },
    },
    perPage: { prompt_in: 160, gen_out: 140 },      // SEO title/desc, og text
    perTemplate: { prompt_in: 240, gen_out: 160 },  // brand voice brief
    regenerationFactor: 1.0,
  },
  RICH: {
    code: 'RICH',
    label: 'Rich (longer copy, a few regenerations)',
    blocks: {
      hero: { prompt_in: 450, gen_out: 280 },
      services: { prompt_in: 380, gen_out: 340 },
      testimonials: { prompt_in: 260, gen_out: 220 },
      page_header: { prompt_in: 200, gen_out: 140 },
      contact_form: ZERO,
      service_areas: { prompt_in: 300, gen_out: 260 },
      faq: { prompt_in: 340, gen_out: 360 },
      about: { prompt_in: 380, gen_out: 360 },
    },
    perPage: { prompt_in: 240, gen_out: 220 },
    perTemplate: { prompt_in: 360, gen_out: 240 },
    regenerationFactor: 1.25,
  },
  MAX: {
    code: 'MAX',
    label: 'Max (long form, retries, variants)',
    blocks: {
      hero: { prompt_in: 700, gen_out: 480 },
      services: { prompt_in: 560, gen_out: 500 },
      testimonials: { prompt_in: 420, gen_out: 360 },
      page_header: { prompt_in: 320, gen_out: 240 },
      contact_form: ZERO,
      service_areas: { prompt_in: 480, gen_out: 440 },
      faq: { prompt_in: 520, gen_out: 560 },
      about: { prompt_in: 600, gen_out: 560 },
    },
    perPage: { prompt_in: 380, gen_out: 360 },
    perTemplate: { prompt_in: 520, gen_out: 360 },
    regenerationFactor: 1.6,
  }
};
```

---

## 4) Core estimator
**`lib/ai/cost/estimate.ts`**
```ts
import type { AssumptionProfile } from './assumptions';
import { ASSUMPTIONS } from './assumptions';
import { getPricing, ModelPricing } from './pricing';

export type TemplateLike = {
  id: string;
  // minimal shape; adapt to your actual type
  pages?: { id: string; title?: string; blocks: { type: string; props?: any }[] }[];
};

export type EstimateInput = {
  entityType: 'template'|'merchant'|'product'|'site';
  entityId: string;
  provider: string;            // e.g. 'openai'
  model_code: string;          // e.g. 'gpt-4o-mini'
  modality?: 'chat';           // for now we focus on chat text gen
  profileCode?: AssumptionProfile['code'];
  // Domain‑specific knobs
  template?: TemplateLike;     // for entityType='template'
  servicesCountPerPage?: number;  // influences services block multiplier
  variantCount?: number;          // e.g., generate 2 hero variants
};

export type EstimateResult = {
  input_tokens: number;
  output_tokens: number;
  images: number;
  minutes_audio: number;
  estimated_cost_usd: number;
  breakdown: Record<string, number>; // label -> USD
};

function requireNumber(v: number | null | undefined, msg: string) {
  if (v === null || v === undefined) throw new Error(msg);
  return v;
}

function tokensToCostUSD(pr: ModelPricing, inputTokens: number, outputTokens: number): number {
  const inUSD = requireNumber(pr.input_per_1k_usd, `Missing input_per_1k_usd for ${pr.provider}:${pr.model_code}`);
  const outUSD = requireNumber(pr.output_per_1k_usd, `Missing output_per_1k_usd for ${pr.provider}:${pr.model_code}`);
  return (inputTokens / 1000) * inUSD + (outputTokens / 1000) * outUSD;
}

export async function estimateTemplateCost(input: EstimateInput): Promise<EstimateResult> {
  const profile = ASSUMPTIONS[input.profileCode ?? 'RICH'];
  const modality = 'chat' as const;
  const pricing = await getPricing(input.provider, input.model_code, modality);

  let totalIn = 0, totalOut = 0;
  const breakdown: Record<string, number> = {};

  const pages = input.template?.pages ?? [];
  const regen = profile.regenerationFactor ?? 1.0;
  const servicesPer = input.servicesCountPerPage ?? 4;
  const variants = input.variantCount ?? 1;

  // Template‑level once
  if (profile.perTemplate) {
    totalIn += profile.perTemplate.prompt_in * regen;
    totalOut += profile.perTemplate.gen_out * regen;
  }

  for (const page of pages) {
    if (profile.perPage) {
      totalIn += profile.perPage.prompt_in * regen;
      totalOut += profile.perPage.gen_out * regen;
    }

    for (const b of page.blocks) {
      const a = profile.blocks[b.type];
      if (!a) continue;
      let inTok = a.prompt_in;
      let outTok = a.gen_out;

      // Special cases by block type
      if (b.type === 'services') {
        // Rough multiplier: assume N items; if provided in props, use that length.
        const n = Array.isArray(b?.props?.items) ? b.props.items.length : servicesPer;
        inTok *= n;
        outTok *= n;
      }

      // Variants for creative blocks like hero/testimonials
      if (b.type === 'hero' || b.type === 'testimonials') {
        inTok *= variants;
        outTok *= variants;
      }

      totalIn += inTok * regen;
      totalOut += outTok * regen;
    }
  }

  const usd = tokensToCostUSD(pricing, totalIn, totalOut);
  breakdown['text_generation'] = usd;

  return {
    input_tokens: Math.round(totalIn),
    output_tokens: Math.round(totalOut),
    images: 0,
    minutes_audio: 0,
    estimated_cost_usd: +usd.toFixed(6),
    breakdown,
  };
}
```

---

## 5) Seeder helper
**`scripts/seed/withAiEstimates.ts`**
```ts
import { createClient } from '@supabase/supabase-js';
import { estimateTemplateCost } from '@/lib/ai/cost/estimate';

const supabaseAdmin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  { auth: { persistSession: false } }
);

type SeededTemplate = { id: string; data?: any; pages?: any[] }; // adapt

type Options = {
  provider?: string;      // default from env
  model_code?: string;    // default from env
  profileCode?: 'BASIC'|'RICH'|'MAX';
};

const DEF_PROVIDER = process.env.AI_DEFAULT_PROVIDER || 'openai';
const DEF_MODEL = process.env.AI_DEFAULT_MODEL || 'gpt-4o-mini';

export async function attachTemplateAiEstimate(t: SeededTemplate, opts: Options = {}) {
  const provider = opts.provider ?? DEF_PROVIDER;
  const model_code = opts.model_code ?? DEF_MODEL;

  const est = await estimateTemplateCost({
    entityType: 'template',
    entityId: t.id,
    provider,
    model_code,
    template: { id: t.id, pages: (t as any).pages || (t as any).data?.pages || [] },
    profileCode: opts.profileCode ?? 'RICH',
  });

  const { error } = await supabaseAdmin.from('ai_estimates').insert({
    entity_type: 'template',
    entity_id: t.id,
    provider,
    model_code,
    assumptions: { profile: opts.profileCode ?? 'RICH' },
    input_tokens: est.input_tokens,
    output_tokens: est.output_tokens,
    images: est.images,
    minutes_audio: est.minutes_audio,
    estimated_cost_usd: est.estimated_cost_usd,
    breakdown: est.breakdown,
  });
  if (error) throw error;

  return est;
}

// Example usage in your existing seeder right after you insert the template:
// const template = await insertTemplate(...);
// await attachTemplateAiEstimate(template, { profileCode: 'RICH' });
```

---

## 6) Account Profile UI card (forecast widget)
**`components/admin/billing/AiCostEstimatorCard.tsx`**
```tsx
'use client';
import { useEffect, useMemo, useState } from 'react';
import { estimateTemplateCost } from '@/lib/ai/cost/estimate';
import { ASSUMPTIONS } from '@/lib/ai/cost/assumptions';
import { Card, CardHeader, CardTitle, CardContent, CardFooter } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Select } from '@/components/ui/select'; // or your select component

export default function AiCostEstimatorCard({ sampleTemplate }: { sampleTemplate?: any }) {
  const [profile, setProfile] = useState<'BASIC'|'RICH'|'MAX'>('RICH');
  const [variants, setVariants] = useState(1);
  const [servicesPer, setServicesPer] = useState(4);
  const [estimate, setEstimate] = useState<null | {
    usd: number; inTok: number; outTok: number; breakdown: Record<string,number>
  }>(null);

  async function run() {
    try {
      const res = await estimateTemplateCost({
        entityType: 'template',
        entityId: 'preview',
        provider: process.env.NEXT_PUBLIC_AI_PROVIDER || 'openai',
        model_code: process.env.NEXT_PUBLIC_AI_MODEL || 'gpt-4o-mini',
        template: sampleTemplate || { pages: [] },
        profileCode: profile,
        servicesCountPerPage: servicesPer,
        variantCount: variants,
      });
      setEstimate({ usd: res.estimated_cost_usd, inTok: res.input_tokens, outTok: res.output_tokens, breakdown: res.breakdown });
    } catch (e:any) {
      setEstimate(null);
      alert(e?.message || 'Failed to estimate. Ensure pricing rows exist.');
    }
  }

  useEffect(() => { run(); /* auto-run */ }, []);

  return (
    <Card className="max-w-xl">
      <CardHeader>
        <CardTitle>AI Cost Forecast</CardTitle>
      </CardHeader>
      <CardContent className="space-y-3">
        <div className="grid grid-cols-2 gap-3">
          <div>
            <Label>Assumptions</Label>
            <select value={profile} onChange={(e)=>setProfile(e.target.value as any)} className="w-full border rounded px-2 py-1">
              {Object.values(ASSUMPTIONS).map(p=> (
                <option key={p.code} value={p.code}>{p.label}</option>
              ))}
            </select>
          </div>
          <div>
            <Label>Hero/Testimonial Variants</Label>
            <Input type="number" min={1} value={variants} onChange={e=>setVariants(parseInt(e.target.value||'1'))} />
          </div>
          <div>
            <Label>Services per page</Label>
            <Input type="number" min={0} value={servicesPer} onChange={e=>setServicesPer(parseInt(e.target.value||'0'))} />
          </div>
        </div>
        <Button onClick={run}>Recalculate</Button>
        {estimate && (
          <div className="mt-2 text-sm">
            <div className="font-medium">Estimated: ${estimate.usd.toFixed(4)} per full generation</div>
            <div>Tokens in/out: {estimate.inTok.toLocaleString()} / {estimate.outTok.toLocaleString()}</div>
          </div>
        )}
      </CardContent>
      <CardFooter className="text-xs text-muted-foreground">
        Uses live prices from <code>ai_model_pricing</code>. Missing rows → throws.
      </CardFooter>
    </Card>
  );
}
```

---

## 7) Template Editor panel (inline cost preview)
**`components/admin/templates/AiCostPreview.tsx`**
```tsx
'use client';
import { useState } from 'react';
import { estimateTemplateCost } from '@/lib/ai/cost/estimate';
import { ASSUMPTIONS } from '@/lib/ai/cost/assumptions';
import { Button } from '@/components/ui/button';

export function AiCostPreview({ template }: { template: any }) {
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState<any>(null);
  const [profile, setProfile] = useState<'BASIC'|'RICH'|'MAX'>('RICH');

  async function calc() {
    setLoading(true);
    try {
      const r = await estimateTemplateCost({
        entityType: 'template',
        entityId: template?.id || 'tmp',
        provider: process.env.NEXT_PUBLIC_AI_PROVIDER || 'openai',
        model_code: process.env.NEXT_PUBLIC_AI_MODEL || 'gpt-4o-mini',
        template,
        profileCode: profile,
      });
      setResult(r);
    } catch (e:any) {
      setResult({ error: e.message });
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="rounded-xl border p-3 text-sm">
      <div className="flex items-center gap-2">
        <select value={profile} onChange={(e)=>setProfile(e.target.value as any)} className="border rounded px-2 py-1">
          {Object.values(ASSUMPTIONS).map(p=> <option key={p.code} value={p.code}>{p.label}</option>)}
        </select>
        <Button size="sm" onClick={calc} disabled={loading}>{loading ? 'Calculating…' : 'Estimate cost'}</Button>
      </div>
      {result && !result.error && (
        <div className="mt-2 grid grid-cols-2 gap-2">
          <div>Input tokens: {result.input_tokens.toLocaleString()}</div>
          <div>Output tokens: {result.output_tokens.toLocaleString()}</div>
          <div className="col-span-2 font-medium">${result.estimated_cost_usd.toFixed(4)} per run</div>
        </div>
      )}
      {result?.error && (
        <div className="mt-2 text-red-600">{String(result.error)}</div>
      )}
    </div>
  );
}
```

---

## 8) Post‑call metering (actuals)
**`lib/ai/withCostLogging.ts`**
```ts
import { createClient } from '@supabase/supabase-js';
import { getPricing } from '@/lib/ai/cost/pricing';

const supabaseAdmin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  { auth: { persistSession: false } }
);

type LogArgs = {
  provider: string;
  model_code: string;
  modality: 'chat'|'embeddings'|'image'|'audio_stt'|'audio_tts';
  template_id?: string;
  site_id?: string;
  user_id?: string;
  // raw usage from provider response
  input_tokens?: number; output_tokens?: number; images?: number; minutes_audio?: number;
  metadata?: Record<string, any>;
};

export async function logActualCost(args: LogArgs) {
  const pricing = await getPricing(args.provider, args.model_code, args.modality);
  let cost = 0;
  if (args.modality === 'chat') {
    const inUSD = pricing.input_per_1k_usd! * ((args.input_tokens || 0) / 1000);
    const outUSD = pricing.output_per_1k_usd! * ((args.output_tokens || 0) / 1000);
    cost = inUSD + outUSD;
  } else if (args.modality === 'embeddings') {
    const inUSD = pricing.input_per_1k_usd! * ((args.input_tokens || 0) / 1000);
    cost = inUSD;
  } else if (args.modality === 'image') {
    const base = pricing.image_base_usd || 0;
    const perMp = pricing.image_per_mp_usd || 0;
    // If you track pixels, add them in metadata and compute megapixels externally
    const images = args.images || 0;
    const mp = (args.metadata?.megapixels_per_image ?? 1);
    cost = images * (base + perMp * mp);
  } else if (args.modality === 'audio_stt') {
    const minutes = args.minutes_audio || 0;
    cost = (pricing.stt_per_min_usd || 0) * minutes;
  } else if (args.modality === 'audio_tts') {
    const chars = args.metadata?.chars || 0;
    cost = (pricing.tts_per_1k_chars_usd || 0) * (chars / 1000);
  }

  const { error } = await supabaseAdmin.from('ai_usage_events').insert({
    user_id: args.user_id || null,
    site_id: args.site_id || null,
    template_id: args.template_id || null,
    provider: args.provider,
    model_code: args.model_code,
    modality: args.modality,
    input_tokens: args.input_tokens || 0,
    output_tokens: args.output_tokens || 0,
    images: args.images || 0,
    minutes_audio: args.minutes_audio || 0,
    cost_usd: +cost.toFixed(6),
    metadata: args.metadata || null,
  });
  if (error) throw error;
  return cost;
}

// Example: wrapping a chat call
// const resp = await openai.chat.completions.create({ model: 'gpt-4o-mini', ... });
// await logActualCost({
//   provider: 'openai', model_code: 'gpt-4o-mini', modality: 'chat', template_id,
//   input_tokens: resp.usage?.prompt_tokens, output_tokens: resp.usage?.completion_tokens,
//   metadata: { route: '/api/generate/home' }
// });
```

---

## 9) Minimal seed for pricing (must fill real numbers)
**`scripts/seed/seedPricing.ts`**
```ts
import { createClient } from '@supabase/supabase-js';

const admin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  { auth: { persistSession: false } }
);

// ⚠️ Populate with your real prices before relying on estimates.
const rows = [
  // Example chat model
  { provider: 'openai', model_code: 'gpt-4o-mini', modality: 'chat', input_per_1k_usd: null, output_per_1k_usd: null },
  // Example embeddings
  { provider: 'openai', model_code: 'text-embedding-3-small', modality: 'embeddings', input_per_1k_usd: null },
];

async function run() {
  const { error } = await admin.from('ai_model_pricing').upsert(rows, { onConflict: 'provider,model_code,modality' });
  if (error) throw error;
  console.log('Seeded ai_model_pricing (placeholders). Fill values in DB UI.');
}

run();
```

---

## 10) Drop‑in usage from your merchant/product/template seeders
**`scripts/seed/exampleUsage.ts`**
```ts
import { attachTemplateAiEstimate } from './withAiEstimates';

export async function seedOneTemplateAndEstimate(tmpl: any) {
  // 1) insert your template first (existing logic)
  // const template = await insertTemplate(tmpl)
  const template = tmpl; // assume we have id

  // 2) attach estimate
  const est = await attachTemplateAiEstimate(template, { profileCode: 'RICH' });
  console.log('AI estimate for template', template.id, est);
}
```

---

# Notes / Next Steps
- Add a **Monthly Forecast** materialized view combining `ai_estimates` (latest per entity) and trailing `ai_usage_events` to display P50/P90 and alert when actual > forecast.
- Expose a small **/admin/settings/ai-pricing** screen to edit `ai_model_pricing` without DB console.
- If you later add image/audio generation, plug their estimates via `breakdown` and modal pricing.
- To avoid skew, log **regenerations** explicitly by tagging `metadata.variantOf` in `ai_usage_events`.


---

## 11) Admin settings page — `/admin/settings/ai-pricing`
Interactive page to **view/add/edit/delete** rows in `ai_model_pricing`. Includes basic admin‑role gating (server‑side) and a service‑role backed API.

**`app/admin/settings/ai-pricing/page.tsx`**
```tsx
'use client';

import { useEffect, useMemo, useState } from 'react';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useCanonicalRole } from '@/hooks/useCanonicalRole';
import toast from 'react-hot-toast';

export type PricingRow = {
  id?: string;
  provider: string;
  model_code: string;
  modality: 'chat'|'embeddings'|'image'|'audio_stt'|'audio_tts';
  input_per_1k_usd?: number | null;
  output_per_1k_usd?: number | null;
  image_base_usd?: number | null;
  image_per_mp_usd?: number | null;
  stt_per_min_usd?: number | null;
  tts_per_1k_chars_usd?: number | null;
  currency?: string;
  is_active?: boolean;
};

const MODALITIES: PricingRow['modality'][] = ['chat','embeddings','image','audio_stt','audio_tts'];

function NumberField({ value, onChange, placeholder }: { value: number | null | undefined; onChange: (v: number | null) => void; placeholder?: string }) {
  const [raw, setRaw] = useState(value == null ? '' : String(value));
  useEffect(()=>{ setRaw(value == null ? '' : String(value)); }, [value]);
  return (
    <Input
      value={raw}
      placeholder={placeholder}
      onChange={(e)=>{
        const v = e.target.value.trim();
        setRaw(v);
        if (v === '') return onChange(null);
        const num = Number(v);
        onChange(Number.isFinite(num) ? num : null);
      }}
    />
  );
}

export default function AiPricingPage() {
  const { role } = useCanonicalRole();
  const [rows, setRows] = useState<PricingRow[]>([]);
  const [loading, setLoading] = useState(true);
  const [savingId, setSavingId] = useState<string | null>(null);

  async function load() {
    setLoading(true);
    const r = await fetch('/api/admin/ai-pricing', { cache: 'no-store' });
    if (!r.ok) {
      toast.error('Failed to load pricing');
      setLoading(false);
      return;
    }
    const data = await r.json();
    setRows(data.rows || []);
    setLoading(false);
  }

  useEffect(() => { load(); }, []);

  function addBlank() {
    setRows((r) => [{ provider: '', model_code: '', modality: 'chat', currency: 'USD', is_active: true }, ...r]);
  }

  async function save(row: PricingRow) {
    if (!row.provider || !row.model_code || !row.modality) {
      toast.error('provider, model_code, modality are required');
      return;
    }
    setSavingId(row.id || `${row.provider}:${row.model_code}:${row.modality}`);
    const res = await fetch('/api/admin/ai-pricing', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(row),
    });
    if (!res.ok) {
      const t = await res.text();
      toast.error(`Save failed: ${t}`);
    } else {
      toast.success('Saved');
      await load();
    }
    setSavingId(null);
  }

  async function remove(row: PricingRow) {
    if (!row.id) {
      // try delete by unique
      const qs = new URLSearchParams({ provider: row.provider, model_code: row.model_code, modality: row.modality }).toString();
      const res = await fetch(`/api/admin/ai-pricing?${qs}`, { method: 'DELETE' });
      if (!res.ok) toast.error('Delete failed'); else { toast.success('Deleted'); load(); }
      return;
    }
    const res = await fetch(`/api/admin/ai-pricing?id=${row.id}`, { method: 'DELETE' });
    if (!res.ok) toast.error('Delete failed'); else { toast.success('Deleted'); load(); }
  }

  if (role && role !== 'admin') {
    return (
      <Card className="mx-auto max-w-5xl">
        <CardHeader><CardTitle>AI Pricing</CardTitle></CardHeader>
        <CardContent>You must be an admin to view this page.</CardContent>
      </Card>
    );
  }

  return (
    <div className="p-6">
      <div className="mx-auto max-w-6xl space-y-4">
        <div className="flex items-center justify-between">
          <h1 className="text-2xl font-semibold">AI Model Pricing</h1>
          <div className="flex items-center gap-2">
            <Button variant="secondary" onClick={load} disabled={loading}>Refresh</Button>
            <Button onClick={addBlank}>Add model</Button>
          </div>
        </div>

        <div className="overflow-x-auto rounded-xl border">
          <table className="w-full text-sm">
            <thead className="bg-muted/40">
              <tr>
                <th className="p-2 text-left">Provider</th>
                <th className="p-2 text-left">Model</th>
                <th className="p-2 text-left">Modality</th>
                <th className="p-2 text-left">Input/1k</th>
                <th className="p-2 text-left">Output/1k</th>
                <th className="p-2 text-left">Image (base)</th>
                <th className="p-2 text-left">Image (/MP)</th>
                <th className="p-2 text-left">STT (/min)</th>
                <th className="p-2 text-left">TTS (/1k chars)</th>
                <th className="p-2 text-left">Active</th>
                <th className="p-2"></th>
              </tr>
            </thead>
            <tbody>
              {rows.map((row, i) => (
                <tr key={(row.id || i) + row.model_code} className="border-t">
                  <td className="p-2 min-w-[140px]"><Input value={row.provider||''} onChange={e=>setRows(rs=>{ const c=[...rs]; c[i] = { ...row, provider: e.target.value }; return c; })} placeholder="openai"/></td>
                  <td className="p-2 min-w-[180px]"><Input value={row.model_code||''} onChange={e=>setRows(rs=>{ const c=[...rs]; c[i] = { ...row, model_code: e.target.value }; return c; })} placeholder="gpt-4o-mini"/></td>
                  <td className="p-2 min-w-[140px]">
                    <select className="border rounded px-2 py-1 w-full" value={row.modality} onChange={e=>setRows(rs=>{ const c=[...rs]; c[i] = { ...row, modality: e.target.value as any }; return c; })}>
                      {MODALITIES.map(m => <option key={m} value={m}>{m}</option>)}
                    </select>
                  </td>
                  <td className="p-2 w-[140px]"><NumberField value={row.input_per_1k_usd ?? null} onChange={v=>setRows(rs=>{ const c=[...rs]; c[i] = { ...row, input_per_1k_usd: v }; return c; })} placeholder="0.150"/></td>
                  <td className="p-2 w-[140px]"><NumberField value={row.output_per_1k_usd ?? null} onChange={v=>setRows(rs=>{ const c=[...rs]; c[i] = { ...row, output_per_1k_usd: v }; return c; })} placeholder="0.600"/></td>
                  <td className="p-2 w-[140px]"><NumberField value={row.image_base_usd ?? null} onChange={v=>setRows(rs=>{ const c=[...rs]; c[i] = { ...row, image_base_usd: v }; return c; })} placeholder="0.040"/></td>
                  <td className="p-2 w-[140px]"><NumberField value={row.image_per_mp_usd ?? null} onChange={v=>setRows(rs=>{ const c=[...rs]; c[i] = { ...row, image_per_mp_usd: v }; return c; })} placeholder="0.010"/></td>
                  <td className="p-2 w-[140px]"><NumberField value={row.stt_per_min_usd ?? null} onChange={v=>setRows(rs=>{ const c=[...rs]; c[i] = { ...row, stt_per_min_usd: v }; return c; })} placeholder="0.006"/></td>
                  <td className="p-2 w-[160px]"><NumberField value={row.tts_per_1k_chars_usd ?? null} onChange={v=>setRows(rs=>{ const c=[...rs]; c[i] = { ...row, tts_per_1k_chars_usd: v }; return c; })} placeholder="0.015"/></td>
                  <td className="p-2 text-center">
                    <input type="checkbox" checked={row.is_active ?? true} onChange={e=>setRows(rs=>{ const c=[...rs]; c[i] = { ...row, is_active: e.target.checked }; return c; })} />
                  </td>
                  <td className="p-2 whitespace-nowrap text-right">
                    <div className="flex items-center gap-2 justify-end">
                      <Button size="sm" onClick={()=>save(row)} disabled={savingId !== null && (savingId === (row.id || `${row.provider}:${row.model_code}:${row.modality}`))}>{savingId ? 'Saving…' : 'Save'}</Button>
                      <Button size="sm" variant="destructive" onClick={()=>remove(row)}>Delete</Button>
                    </div>
                  </td>
                </tr>
              ))}
              {!rows.length && !loading && (
                <tr><td className="p-4 text-center text-muted-foreground" colSpan={11}>No rows. Click “Add model”.</td></tr>
              )}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
}
```

---

## 12) Admin API — `app/api/admin/ai-pricing/route.ts`
Server‑only API using **service role** for writes, and **admin role** check via session.

```ts
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { createServerClient } from '@supabase/ssr';
import { createClient } from '@supabase/supabase-js';

function serverAnon() {
  const cookieStore = cookies();
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get: (name: string) => cookieStore.get(name)?.value,
        set: (name: string, value: string, options: any) => cookieStore.set({ name, value, ...options }),
        remove: (name: string) => cookieStore.set({ name, value: '', expires: new Date(0) }),
      },
    }
  );
}

const admin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  { auth: { persistSession: false } }
);

async function requireAdmin() {
  const supabase = serverAnon();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return null;
  const { data: prof } = await supabase.from('profiles').select('role').eq('id', user.id).maybeSingle();
  if (prof?.role !== 'admin') return null;
  return user;
}

function num(v: any) {
  if (v === null || v === undefined || v === '') return null;
  const n = Number(v); return Number.isFinite(n) ? n : null;
}

export async function GET() {
  const user = await requireAdmin();
  if (!user) return NextResponse.json({ error: 'forbidden' }, { status: 403 });
  const { data, error } = await admin.from('ai_model_pricing').select('*').order('provider', { ascending: true }).order('model_code', { ascending: true }).order('modality', { ascending: true });
  if (error) return NextResponse.text(error.message, { status: 500 });
  return NextResponse.json({ rows: data });
}

export async function POST(req: NextRequest) {
  const user = await requireAdmin();
  if (!user) return NextResponse.json({ error: 'forbidden' }, { status: 403 });
  const body = await req.json();

  const payload = {
    id: body.id ?? undefined,
    provider: body.provider,
    model_code: body.model_code,
    modality: body.modality,
    input_per_1k_usd: num(body.input_per_1k_usd),
    output_per_1k_usd: num(body.output_per_1k_usd),
    image_base_usd: num(body.image_base_usd),
    image_per_mp_usd: num(body.image_per_mp_usd),
    stt_per_min_usd: num(body.stt_per_min_usd),
    tts_per_1k_chars_usd: num(body.tts_per_1k_chars_usd),
    currency: body.currency ?? 'USD',
    is_active: body.is_active ?? true,
  };

  if (!payload.provider || !payload.model_code || !payload.modality) {
    return NextResponse.text('provider, model_code, modality are required', { status: 400 });
  }

  // Upsert by unique(provider, model_code, modality)
  const { error } = await admin.from('ai_model_pricing').upsert(payload, { onConflict: 'provider,model_code,modality' });
  if (error) return NextResponse.text(error.message, { status: 500 });
  return NextResponse.json({ ok: true });
}

export async function DELETE(req: NextRequest) {
  const user = await requireAdmin();
  if (!user) return NextResponse.json({ error: 'forbidden' }, { status: 403 });
  const { searchParams } = new URL(req.url);
  const id = searchParams.get('id');
  const provider = searchParams.get('provider');
  const model_code = searchParams.get('model_code');
  const modality = searchParams.get('modality');

  let qb = admin.from('ai_model_pricing').delete();
  if (id) qb = qb.eq('id', id);
  else if (provider && model_code && modality) qb = qb.eq('provider', provider).eq('model_code', model_code).eq('modality', modality);
  else return NextResponse.text('Missing id or unique keys', { status: 400 });

  const { error } = await qb;
  if (error) return NextResponse.text(error.message, { status: 500 });
  return NextResponse.json({ ok: true });
}
```

---

## 13) Optional RLS policies (if you prefer not to rely on service‑role writes)
Add to your migration to allow **admins** to manage pricing directly via anon client.

**`supabase/migrations/20250829_ai_cost_policies.sql`**
```sql
alter table public.ai_model_pricing enable row level security;

-- Everyone can read prices
create policy ai_model_pricing_read_all
  on public.ai_model_pricing
  for select
  to authenticated, anon
  using (true);

-- Only admins (profiles.role = 'admin') can insert/update/delete
create policy ai_model_pricing_admin_write
  on public.ai_model_pricing
  for all
  to authenticated
  using (exists (
    select 1 from public.profiles p where p.id = auth.uid() and p.role = 'admin'
  ))
  with check (exists (
    select 1 from public.profiles p where p.id = auth.uid() and p.role = 'admin'
  ));
```

---

## 14) Hook into Admin nav
Add an item under **Settings** → **AI Pricing**.

**`components/admin/AppHeader/AdminNavSections.tsx`** (snippet)
```tsx
// Inside your settings section items
{
  type: 'item',
  label: 'AI Pricing',
  href: '/admin/settings/ai-pricing',
  icon: <Wrench />,
}
```

---

## 15) Sanity checks
- Visit **/admin/settings/ai-pricing** while logged in as admin → add real prices.
- Re‑run a template estimate in the editor/Profile card → should show non‑throwing totals.
- Create/update/delete models and confirm the estimator reflects new values immediately.
